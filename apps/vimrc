set nocompatible              " be iMproved, required
filetype off                  " required

" Disable Markdown syntax highlighting via vim-polyglot (use vim-markdown
" instead).
"
" NOTE: This variable must be set *before* vim-polyglot is loaded.
let g:polyglot_disabled = ['markdown']

call plug#begin('~/.config/vim/plugged')
  " Language / code
  Plug 'dense-analysis/ale'
  Plug 'godlygeek/tabular'
  Plug 'preservim/vim-markdown', { 'for': 'markdown' }
  Plug 'preservim/nerdcommenter'
  Plug 'editorconfig/editorconfig-vim'

  "Plug 'jiangmiao/auto-pairs'
  Plug 'tpope/vim-surround'
  Plug 'ervandew/supertab'
  Plug 'sheerun/vim-polyglot'

  " Theme
  Plug 'morhetz/gruvbox'

  " QOL
  Plug 'AndrewRadev/switch.vim'
  Plug 'justinmk/vim-sneak'
  Plug 'mg979/vim-visual-multi', {'branch': 'master'}

  " Git integration
  Plug 'tpope/vim-fugitive'
  Plug 'rbong/vim-flog'
  Plug 'airblade/vim-gitgutter'

  " Interface
  Plug 'preservim/nerdtree', { 'on': 'NERDTreeToggle' }
  Plug 'tiagofumo/vim-nerdtree-syntax-highlight'
  Plug 'junegunn/fzf.vim'
  Plug 'vim-airline/vim-airline'

  " Should be called last
  Plug 'ryanoasis/vim-devicons'
call plug#end()

" Basic Configuration
set backup                   " Enable backups
set swapfile                 " Enable swapfiles
set backupdir=~/.vim/backup/ " Backup dir
set directory=~/.vim/swp/    " Swp file dir
set hidden                   " hides buffer
set history=1000             " remember more commands and search history
set undolevels=1000          " use many muchos levels of undo
set wildignore=*.swp,*.bak,*.pyc,*.class
set title                    " change the terminal's title
set noerrorbells             " don't beep

" change the mapleader from \ to ,
let mapleader=","

" Set character encoding.
set encoding=utf-8
scriptencoding utf-8

" Set split behavior.
set splitbelow  " Horizontal split (:split, :sp) below current pane.
set splitright  " Vertical split (:vsplit, :vs) right of current pane.

" Quickly edit/reload the vimrc file
nmap <silent> <leader>ev :e $MYVIMRC<CR>
nmap <silent> <leader>sv :so $MYVIMRC<CR>

" Display
set ruler                       " Position du fichier tjs affichée
set showmode                    " Montre le mode actuel
set number                      " Afficher les numéros de ligne
syntax on                       " Coloration syntaxique
set wrap                        " Pas de wordwrap
set showmatch                   " Donne parenthèse correspondante
set showcmd                     " Donne commande incomplète
set autoindent                  " Indentation auto
set copyindent                  " Copier l'indentation existante
set shiftround                  " use multiple of shiftwidth when indenting with '<' and '>'
set showmatch                   " set show matching parenthesis
set ignorecase                  " ignore case when searching
set smartcase                   " ignore case if search pattern is all lowercase,
set smarttab                    " insert tabs on the start of a line
set incsearch                   " Recherche incrémentale
set hlsearch                    " Surligne les résultats de recherche
set expandtab                   " Utilise  plutot que
set softtabstop=2               " Largeur de tab
set sta                         " Smart tabs
set shiftwidth=2                " Largeur d'indentation
set ru                          " Position dans le fichier donnée
set hlg=en                      " Langue de l'aide : english
set mousemodel=popup            " Affiche un popup au clic droit
set showtabline=2               " Affiche tout le temps la ligne des tabs
set numberwidth=5               " Nombre de colonnes que prend les numéros de lignes
set pastetoggle=<F2>            " pour eviter de faire de la cascade
set ffs=unix,dos
" Configure status line.
set laststatus=2  " Always show the status line.
set noshowmode    " Removes duplicate mode message (use vim-airline instead).
set updatetime=250

" Set IncSearch color.
highlight IncSearch cterm=bold ctermfg=166 ctermbg=235 guifg=#d65d0e guibg=#282828

" Set Error color.
highlight Error cterm=bold ctermfg=167 ctermbg=235 guifg=#fb4934 guibg=#282828

" Set SignColumn color.
highlight SignColumn ctermbg=235 guibg=#282828

" Configure automatic formatting.
"   r  Automatically insert the current comment leader after hitting <Enter>.
"   o  Automatically insert the current comment leader after hitting 'o' or 'O'.
"   c  Auto-wrap comments using 'textwidth'. Insert the current comment leader.
"   q  Allow formatting of comments with 'gq'.
"   n  When formatting text, recognize numbered lists.
"   1  Don't break a line after a one-letter word.
"   j  Remove a comment leader when joining lines.
set formatoptions=rocqn1j

" Center search results after jumping.
"   n   Next search result
"   N   Previous search result
"   *   Search for word under cursor forward
"   #   Search for word under cursor backward
"   g*  Search for partial match forward
"   g#  Search for partial match backward
nnoremap n  nzz
nnoremap N  Nzz
nnoremap *  *zz
nnoremap #  #zz
nnoremap g* g*zz
nnoremap g# g#zz

" Some useful commands
" Show invisible char with F3
set listchars=tab:▸\ ,eol:↲,precedes:«,extends:»,nbsp:␣,trail:•
highlight SpecialKey cterm=NONE ctermbg=160 ctermfg=231 gui=NONE guifg=#ffffff guibg=#d70000
nnoremap <F3> :set list!<CR>
" Detect sqli pattern on current line and cast to int
nnoremap <F4> :s/\.\s*\(\$id\w*\\|\\$w*id\\|\$_\w*\[.\{-}\]\\|Tools::getValue(.\{-})\)/\. (int) \1/gci<CR>
" Detect sqli pattern in the open buffer from the current line and cast to int
nnoremap <F5> :,$s/\.\s*\(\$id\w*\\|\\$w*id\\|\$_\w*\[.\{-}\]\\|Tools::getValue(.\{-})\)/\. (int) \1/gci<CR>
" Replace a bad pSQL by a int from the current line
nnoremap <F6> :,$s/\.\s*pSQL(\s*\(\$id\w*\\|\\$w*id\\|\$_\w*\[.\{-}\]\\|Tools::getValue(.\{-})\)\s*)/\. (int) \1/gci<CR>
" Add a pSQL for user retrieved var from the current line
nnoremap <F7> :,$s/\.\s*\((string)\)\?\(\$_\w*\[.\{-}\]\\|\s*\$\w*\[.\{-}\]\\|Tools::getValue(.\{-})\\|\$\w*\)/\. pSQL( \2 )/gci<CR>
" Replace a user provided array by int from the current line
nnoremap <F8> :,$s/\.\s*\(\$id\w*\\|\\$w\\|\$_\w*\[.\{-}\]\\|Tools::getValue(.\{-})\)/\. implode(', ', array_map('intval', explode(',',  \1 )))/gci<CR>
" Encapsulate a bad escaped psql
nnoremap <F9> :,$s/=\s*'\s*\.\s*\(pSQL(\s*\(\$_\w*\['\w*'\]\\|\$\w*\\|Tools::getValue(.\{-})\)\s*)\)\s*\.\s*'/= "' . \1 . '"/gci<CR>
" soa serial
nnoremap <F12> /\<\d\{10}\><CR>ce<C-r>=strftime("%Y%m%d00")<CR><Esc>:echo @"<CR>

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo /usr/bin/tee > /dev/null %
cmap hex %!xxd
" Options du GUI
set guioptions=ecimMgrp

set statusline+=%#warningmsg#
set statusline+=%*

let g:ackprg = 'ag --nogroup --nocolor --column --smart-case'

" Options internes
set ul=100              " Niveaux d'annulation
set mouse=v             " only in visual mode

if v:version < 800
    set t_Co=256           " Terminaux à 256 couleurs
    colorscheme desert
    let g:airline_theme='base16_tomorrow'
else
    if empty($DISPLAY)
        set background=dark
    else
        source ~/.vim/vimrc.background
    endif
    if (has("termguicolors"))
        set termguicolors
    endif
    let g:gruvbox_italic=1
    let g:gruvbox_contrast_dark='medium'
    let g:gruvbox_contrast_light='hard'
    let g:airline_theme='gruvbox'
    silent! colorscheme gruvbox
endif

" italic comment
highlight Comment cterm=italic gui=italic

" trailing white space
match ErrorMsg '\s\+$'

function! TrimWhiteSpace()
    %s/\s\+$//e
endfunction
nnoremap <silent> <Leader>rts :call TrimWhiteSpace()<CR>

" Navigation entre les buffers
map <C-right> <ESC>:bn<CR>
map <C-left> <ESC>:bp<CR>

imap sdf <ESC>
" To save, ctrl-s.
map <c-s> <Esc>:w<CR>a
map <C-s> <ESC>:w<CR>
imap <C-s> <ESC>:w<CR>a
" Complete options (disable preview scratch window)
set completeopt=menu,menuone,longest
" Limit popup menu height
set pumheight=15

" Options de complétion générale
set completeopt=menu,longest " Options de completion

" Wildmenu (pour faire un petit menu sympa quand on tape une commande VIM)
set wildmenu
set wildmode=longest:full

" reprendre à la dernière ligne
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

" detect nagios config
autocmd BufNewFile,BufRead */nagios*/*.{cache,cfg,jinja2} setlocal filetype=nagios

nnoremap rm :call delete(expand('%')) \| bdelete! <CR>
nnoremap <leader>wd :write\|bdelete <CR>
nnoremap <leader>x :bdelete<cr>

" use - as a switch key
let g:switch_mapping = "-"

nnoremap ;; m`A;<Esc>``
nnoremap ,, m`A,<Esc>``
nnoremap ## m`I#<Esc>``
nnoremap <leader>' di'
nnoremap <leader>" di"
nnoremap <Leader>q" ciW""<Esc>P
nnoremap <Leader>q' ciW''<Esc>P
nnoremap <Leader>qd daW"=substitute(@@,"'\\\|\"","","g")<CR>P
nnoremap <Leader>v <c-v>

""""""""""""""""""""""""
" Plugin configuration "
""""""""""""""""""""""""

" Sneak configuration
let g:sneak#s_next = 1

" Airline configuration
let g:airline#extensions#tabline#enabled = 1

" Enable Powerline fonts.
let g:airline_powerline_fonts = 1

" Disable ALE integration.
let g:airline#extensions#ale#enabled = 1

" Disable detection of whitespace errors.
let g:airline#extensions#whitespace#enabled = 0

" Enable branch information (requires vim-fugitive).
let g:airline#extensions#branch#enabled = 1

" Enable hunk information (requires vim-gitgutter).
let g:airline#extensions#hunks#enabled = 1

" Enable NERDTree integration. See NERDTreeStatusline.
let g:airline#extensions#nerdtree_statusline = 1

let g:ale_fixers = {
\   '*': ['remove_trailing_lines', 'trim_whitespace'],
\   'go': ['goimports'],
\   'python': ['ruff', 'ruff_format'],
\   'javascript': ['eslint', 'prettier'],
\   'typescript': ['eslint', 'prettier'],
\   'typescriptreact': ['eslint', 'prettier'],
\   'sh': ['shfmt'],
\   'markdown': ['remove_trailing_lines'],
\   'css': ['prettier'],
\   'scss': ['prettier'],
\   'html': ['prettier'],
\   'json': ['prettier'],
\   'yaml': ['prettier'],
\   'yml': ['prettier'],
\   'xml': ['xmllint'],
\   'terraform': ['terraform'],
\}

let g:ale_linters = {
\   'go': ['golangci-lint'],
\   'python': ['ruff', 'mypy'],
\   'javascript': ['eslint'],
\   'typescript': ['eslint', 'tsc'],
\   'typescriptreact': ['eslint', 'tsc'],
\   'sh': ['shellcheck'],
\   'markdown': ['cspell', 'vale'],
\   'yaml': ['yamllint'],
\   'dockerfile': ['hadolint'],
\   'terraform': ['terraform', 'tflint', 'tfsec'],
\}

let g:ale_sh_shellcheck_options = '-x'

" Disable ALE for specific buffer types (NERDTree, help, etc.).
let g:ale_pattern_options_enabled = 1
augroup DisableALEForSpecialBuffers
  autocmd!
  autocmd FileType nerdtree let b:ale_enabled = 0
augroup END

" Show error details in preview window.
nnoremap <silent> <Leader>ad <Plug>(ale_detail)

" Only lint on enter and save.
"   - Do not lint on text change.
"   - Do not lint on insert leave.
" This configuration enables better performance and fewer distractions.
let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_insert_leave = 0

" ALE commands.
nnoremap <silent> <Leader>af :ALEFix<CR>
nnoremap <silent> <Leader>ai :ALEInfo<CR>
nnoremap <silent> <Leader>ar :ALEReset<CR>
nnoremap <silent> <Leader>at :ALEToggle<CR>

"autocmd VimEnter * redraw!

" Open fzf
map <C-p> :Files<CR>

let g:fzf_vim = {}

" Set key bindings for opening selected files.
let g:fzf_action = {
      \ 'ctrl-t': 'tab split',
      \ 'ctrl-s': 'split',
      \ 'ctrl-v': 'vsplit' }

" Do not open files in NERDTree buffer.
nnoremap <silent> <expr> <C-P> (expand('%') =~ 'NERD_tree' ? "\<C-W>\<C-W>" : '').":Files\<CR>"

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim-gitgutter
"
" vim-gitgutter is a popular Vim plugin that visually integrates Git diff
" information with the buffer's gutter (i.e., the sign column to the left of
" the line numbers).
"
" Mappings:
"
"   ]c          Jump to next hunk
"   [c          Jump to previous hunk
"   <Leader>hp  Preview hunk
"   <Leader>hs  Stage hunk
"   <Leader>hu  Undo  hunk
"
" See: https://github.com/airblade/vim-gitgutter
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Center hunk after jumping.
nmap ]c <Plug>(GitGutterNextHunk)zz
nmap [c <Plug>(GitGutterPrevHunk)zz

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" NERDTree
"
" NERDTree is a popular file system explorer plugin for the Vim text editor.
" It provides a tree-style navigation panel that displays your project's
" directory structure in a sidebar, making it easier to browse and manage
" files without leaving Vim.
"
" See: https://github.com/preservim/nerdtree
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Show hidden files by default.
let g:NERDTreeShowHidden = 1

" Ignore specific files.
let g:NERDTreeIgnore=[
      \ '\.git$[[dir]]',
      \ '\.mypy_cache$[[dir]]',
      \ '\.pytest_cache$[[dir]]',
      \ '\.ruff_cache$[[dir]]',
      \ '__pycache__$[[dir]]',
      \ 'node_modules$[[dir]]',
      \ '\.DS_Store$[[file]]',
      \ '\.pyc$[[file]]',
      \ '\.swo$[[file]]',
      \ '\.swp$[[file]]',
      \ '\~$[[file]]'
      \ ]

" Do not show 'Bookmarks' and 'Press ? for help' text.
let g:NERDTreeMinimalUI = 1

" Set window width.
let g:NERDTreeWinSize = 35

" Toggle NERDTree (if closed, open it; if open, close it).
nnoremap <C-t> :NERDTreeToggle<CR>
nnoremap <Leader>nt :NERDTree %:p:h<CR>

" Open nerdthree
nnoremap <C-o> :NERDTreeFocus<CR>

" Find the file for the active buffer in the NERDTree window.
nnoremap <C-f> :NERDTreeFind<CR>

" Use case-sensitive sort of nodes.
let g:NERDTreeCaseSensitiveSort = 1

" Start NERDTree and put the cursor back in the other window.
autocmd VimEnter * silent! NERDTree | wincmd p

" If another buffer tries to replace NERDTree, put it in the other window, and bring back NERDTree.
autocmd BufEnter * if winnr() == winnr('h') && bufname('#') =~ 'NERD_tree_\d\+' && bufname('%') !~ 'NERD_tree_\d\+' && winnr('$') > 1 |
    \ let buf=bufnr() | buffer# | execute "normal! \<C-W>w" | execute 'buffer'.buf | endif

" Airline configuration
let g:airline#extensions#tabline#enabled = 1
" Enable Powerline fonts.
let g:airline_powerline_fonts = 1

" Enable ALE integration.
let g:airline#extensions#ale#enabled = 1

" Disable detection of whitespace errors.
let g:airline#extensions#whitespace#enabled = 0

" Enable branch information (requires vim-fugitive).
let g:airline#extensions#branch#enabled = 1

" Enable hunk information (requires vim-gitgutter).
let g:airline#extensions#hunks#enabled = 1

" Enable NERDTree integration. See NERDTreeStatusline.
let g:airline#extensions#nerdtree_statusline = 1


if version >= 900
    " Exit Vim if NERDTree is the only window remaining in the only tab.
    autocmd BufEnter * if tabpagenr('$') == 1
        \ && winnr('$') == 1
        \ && exists('b:NERDTree')
        \ && b:NERDTree.isTabTree()
        \ | call feedkeys(":quit\<CR>:\<BS>")
        \ | endif

    " Close the tab if NERDTree is the only window remaining in it.
    autocmd BufEnter * if winnr('$') == 1
        \ && exists('b:NERDTree')
        \ && b:NERDTree.isTabTree()
        \ | call feedkeys(":quit\<CR>:\<BS>")
        \ | endif
else
    " Exit Vim if NERDTree is the only window remaining in the only tab.
    autocmd BufEnter * if tabpagenr('$') == 1
        \ && winnr('$') == 1
        \ && exists('b:NERDTree')
        \ && b:NERDTree.isTabTree()
        \ | quit
        \ | endif

    " Close the tab if NERDTree is the only window remaining in it.
    autocmd BufEnter * if winnr('$') == 1
        \ && exists('b:NERDTree') && b:NERDTree.isTabTree()
        \ | quit
        \ | endif
endif

inoremap <special> <expr> <Esc>[200~ XTermPasteBegin()

" Do not fold markdown by default
let g:vim_markdown_folding_disabled = 1

" Sneak configuration
let g:sneak#s_next = 1
let g:sneak#label = 1

function! XTermPasteBegin()
  set pastetoggle=<Esc>[201~
  set paste
  return ""
endfunction

" iTerm2 cursor types:
"   Ps = 0  -> blinking block.
"   Ps = 1  -> blinking block (default).
"   Ps = 2  -> steady block.
"   Ps = 3  -> blinking underline.
"   Ps = 4  -> steady underline.
"   Ps = 5  -> blinking bar (xterm).
"   Ps = 6  -> steady bar (xterm).

if !exists('g:normal_cursor')
    let g:normal_cursor = 2
endif
if !exists('g:insert_cursor')
    let g:insert_cursor = 5
endif
if !exists('g:replace_cursor')
    let g:replace_cursor = 1
endif
if !exists('g:original_cursor')
    let g:original_cursor = 5
endif

if !exists('g:normal_cursor_color')
    let g:normal_cursor_color = "cyan"
endif
if !exists('g:insert_cursor_color')
    let g:insert_cursor_color = "black"
endif
if !exists('g:replace_cursor_color')
    let g:replace_cursor_color = "orange"
endif
if !exists('g:original_cursor_color')
    let g:original_cursor_color = "black"
endif

let s:inside_tmux = exists('$TMUX')

function! s:WrapForTmux(s)
    if !s:inside_tmux
        return a:s
    endif

    let tmux_start = "\ePtmux;"
    let tmux_end   = "\e\\"

    return tmux_start . substitute(a:s, "\e", "\e\e", 'g') . tmux_end
endfunction

" These sequences save/restore the screen.
" They should NOT be wrapped in tmux escape sequences for some reason!
let save_screen    = "\e[?1049h"
let restore_screen = "\e[?1049l"

let cursor_to_normal = s:WrapForTmux("\e[" . g:normal_cursor . " q\x7\e]12;" . g:normal_cursor_color . "\x7")
let cursor_to_insert = s:WrapForTmux("\e[" . g:insert_cursor . " q\x7\e]12;" . g:insert_cursor_color . "\x7")
let cursor_to_replace = s:WrapForTmux("\e[" . g:replace_cursor . " q\x7\e]12;" . g:replace_cursor_color . "\x7")
let cursor_to_original = s:WrapForTmux("\e[" . g:original_cursor . " q\x7\e]12;" . g:original_cursor_color ."\x7" . '"')

let paste_to_insert = "\e[?2004h"
let paste_to_normal = "\e[?2004l"

let &t_ti .= cursor_to_normal . save_screen
let &t_te = restore_screen

let &t_SI .= cursor_to_insert
let &t_SI .= paste_to_insert
let &t_EI .= cursor_to_normal
let &t_EI .= paste_to_normal
let &t_SR .= cursor_to_replace

" reset cursor when vim exits
autocmd VimLeave * silent execute '!echo -ne "' . cursor_to_original

" initialize cursor shape/color on startup (silent !echo approach doesn't seem to work for tmux)
augroup ResetCursorShape
    au!
    autocmd VimEnter * normal! :startinsert :stopinsert
augroup END

autocmd InsertEnter,InsertLeave * set cul!
