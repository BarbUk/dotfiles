#!/bin/bash
# shellcheck shell=bash
# shellcheck disable=SC2034
give_me_hostname="give_me_hostname"
fzf_default_options="-i --select-1 --exit-0 --tac --tiebreak=length,begin,index --reverse --inline-info"
fzf_height="--height ${FZF_TMUX_HEIGHT:-66%} --min-height 25"

export COMP_WORDBREAKS=${COMP_WORDBREAKS/\:/}
export FZF_COMPLETION_TRIGGER=''

# Tools to complete
net_tools=(
  ping
  host
  mtr
  mosh
  telnet
  ftp
  lftp
  dig
  drill
  nslookup
  ansible
  nmap
)

ssh_tools=(
  ssh
  s
  n
  rsync
  scp
  sftp
  proo
  curl
  ssh-audit
  update-services
  connect_to_proo
  mysql_get_root_password
)

process_tools=(
  pgrep
  pkill
  killall
)

# Use fd (https://github.com/sharkdp/fd) instead of the default find
# command for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
# shellcheck disable=2329
_fzf_compgen_path() {
  if command -v bfs >/dev/null 2>&1; then
    bfs -H "$1" -color -exclude \( -name .git \) 2>/dev/null
  elif command -v fd >/dev/null 2>&1; then
    fd --hidden --max-depth 5 --follow --exclude ".git" . "$1"
  else
    echo "$1"
    command find -L "$1" \
      -name .git -prune -o -name .hg -prune -o -name .svn -prune -o \( -type d -o -type f -o -type l \) \
      -a -not -path "$1" -print 2>/dev/null | command sed 's@^\./@@'
  fi
}

# Use fd to generate the list for directory completion
# shellcheck disable=2329
_fzf_compgen_dir() {
  if command -v bfs >/dev/null 2>&1; then
    bfs -H "$1" -color -exclude \( -name .git \) -type d 2>/dev/null
  elif command -v fd >/dev/null 2>&1; then
    fd --type d --hidden --max-depth 3 --follow --exclude ".git" . "$1"
  else
    command find -L "$1" \
      -name .git -prune -o -name .hg -prune -o -name .svn -prune -o -type d \
      -a -not -path "$1" -print 2>/dev/null | command sed 's@^\./@@'
  fi
}

# fzf default completion
#[[ -f /usr/share/fzf/completion.bash ]] && source /usr/share/fzf/completion.bash

_complete() {
  local current="${COMP_WORDS[COMP_CWORD]}"

  if [[ ${current} == *@* ]]; then
    local opts="-P ${current/@*/}@ -- ${current/*@/}"
  else
    local opts=" -- ${current}"
  fi
  # shellcheck disable=SC2086,2207
  COMPREPLY=($(compgen -W "$(</dev/stdin)" ${opts}))
  return 0
}

_fzf_privkey() {
  find "$HOME/.ssh" -type f -name 'id_*' | grep -v '.pub'
}

_fzf_playbook() {
  find playbooks -maxdepth 1 -type f -name '*.yml'
}

_fzf_ansible_groups() {
  local inventory
  if [ -e "$HOME"/.ansible.cfg ] && grep -q inventory "$HOME"/.ansible.cfg; then
    inventory=$(awk '/inventory/ {print $3}' "$HOME"/.ansible.cfg)
    inventory=${inventory/\~/$HOME}
  elif [ -e ansible.cfg ] && grep -q inventory ansible.cfg; then
    inventory=$(awk '/inventory/ {print $3}' ansible.cfg)
  fi
  ansible-inventory --list | jq -r "keys | .[]"
}

_fzf_dsh_groups() {
  local inventory
  inventory="$HOME/.dsh/group"
  if [ -d "$inventory" ]; then
    ls -1 "$inventory"
  fi
}

_fzf_archlinux_installed_packages() {
  pacman -Qq
}

_fzf_log() {
  local cmd log_file
  cmd="command find /var/log/ -type f -name '*log' 2>/dev/null"
  log_file=$(eval "$cmd" | fzf "$fzf_height" --tac --tiebreak=length,begin,index --reverse --inline-info) && less "$log_file"
}

_fzf_complete() {
  local selected fzf post caller
  local current="${COMP_WORDS[COMP_CWORD]}"
  local user_prefix=''
  local options="${1:-'--multi'}"
  local separator=${2:- }
  local preview="fzf_preview {}"
  caller=$(caller 0 | awk '{print $2}')
  local delete="fzf_delete $caller {}"

  post="${caller}_post"
  type -t "$post" >/dev/null 2>&1 || post='command cat'
  fzf="fzf $fzf_default_options $options $fzf_height --preview-window right:75%:hidden --bind ?:toggle-preview"

  if [[ ${current} == *@* ]]; then
    user_prefix="${current/@*/}@"
    current="${current/*@/}"
  fi
  selected=$(cat | $fzf --preview "$preview" --bind "alt-bspace:execute:$delete" --query "$current" | $post | tr '\n' "$separator")
  selected=${selected%"$separator"} # Strip trailing space not to repeat "-o nospace"
  printf '\e[5n'

  if [ -n "$selected" ]; then
    COMPREPLY=("${user_prefix}${selected}")
    return 0
  fi
}

__fzf_exec_awk() {
  __fzf_awk='awk'
  LC_ALL=C exec "$__fzf_awk" "$@"
}

__fzf_comprun() {
  if [[ "$(type -t _fzf_comprun 2>&1)" == function ]]; then
    _fzf_comprun "$@"
  elif [[ -n ${TMUX_PANE-} ]] && {
    [[ ${FZF_TMUX:-0} != 0 ]] || [[ -n ${FZF_TMUX_OPTS-} ]]
  }; then
    shift
    # shellcheck disable=2086
    fzf-tmux ${FZF_TMUX_OPTS:--d${FZF_TMUX_HEIGHT:-40%}} -- "$@"
  else
    shift
    fzf "$@"
  fi
}

__fzf_orig_completion() {
  local l comp f cmd
  while read -r l; do
    if [[ $l =~ ^(.*\ -F)\ *([^ ]*).*\ ([^ ]*)$ ]]; then
      comp="${BASH_REMATCH[1]}"
      f="${BASH_REMATCH[2]}"
      cmd="${BASH_REMATCH[3]}"
      [[ $f == _fzf_* ]] && continue
      printf -v "_fzf_orig_completion_${cmd//[^A-Za-z0-9_]/_}" "%s" "${comp} %s ${cmd} #${f}"
      if [[ $l == *" -o nospace "* ]] && [[ ${__fzf_nospace_commands-} != *" $cmd "* ]]; then
        __fzf_nospace_commands="${__fzf_nospace_commands-} $cmd "
      fi
    fi
  done
}

# @param $1 cmd - Command name for which the original completion is searched
# @var[out] REPLY - Original function name is returned
__fzf_orig_completion_get_orig_func() {
  local cmd orig_var orig
  cmd=$1
  orig_var="_fzf_orig_completion_${cmd//[^A-Za-z0-9_]/_}"
  orig="${!orig_var-}"
  REPLY="${orig##*#}"
  [[ $REPLY ]] && type "$REPLY" &>/dev/null
}

# @param $1 cmd - Command name for which the original completion is searched
# @param $2 func - Fzf's completion function to replace the original function
# @var[out] REPLY - Completion setting is returned as a string to "eval"
__fzf_orig_completion_instantiate() {
  local cmd func orig_var orig
  cmd=$1
  func=$2
  orig_var="_fzf_orig_completion_${cmd//[^A-Za-z0-9_]/_}"
  orig="${!orig_var-}"
  orig="${orig%#*}"
  [[ $orig == *' %s '* ]] || return 1
  # shellcheck disable=2059
  printf -v REPLY "$orig" "$func"
}

__fzf_defaults() {
  printf '%s\n' "$fzf_height $fzf_default_options --min-height 20+ --bind=ctrl-z:ignore $1"
  command cat "${FZF_DEFAULT_OPTS_FILE-}" 2>/dev/null
  printf '%s\n' "${FZF_DEFAULT_OPTS-} $2"
}

_fzf_complete_new() {
  # Split arguments around --
  local args rest str_arg i sep output_separator=" " default_preview=true
  args=("$@")
  sep=
  for i in "${!args[@]}"; do
    if [[ ${args[$i]} = "--output_separator="* ]]; then
      output_separator="${args[i]#*=}"
      unset 'args[i]'
    fi
    if [[ ${args[$i]} = "--preview" ]]; then
      default_preview=false
    fi
    if [[ ${args[$i]} == -- ]]; then
      sep=$i
      break
    fi
  done
  if [[ -n $sep ]]; then
    str_arg=
    rest=("${args[@]:$((sep + 1)):${#args[@]}}")
    args=("${args[@]:0:sep}")
  else
    str_arg=$1
    args=()
    shift
    rest=("$@")
  fi

  local current selected cmd post caller user_prefix=''
  local preview="fzf_preview {}"
  caller=$(caller 0 | awk '{print $2}')
  local delete="fzf_delete $caller {}"
  post="${caller}_post"
  type -t "$post" >/dev/null 2>&1 || post='command cat'

  if [ "$default_preview" = true ]; then
    args+=(--preview "$preview" --preview-window right:75%:hidden --bind ?:toggle-preview)
  fi
  args+=(--bind "alt-bspace:execute:$delete")

  cmd="${COMP_WORDS[0]}"
  current="${COMP_WORDS[COMP_CWORD]}"

  if [[ ${current} == *@* ]]; then
    user_prefix="${current/@*/}@"
    current="${current/*@/}"
  fi

  selected=$(
    FZF_DEFAULT_OPTS=$(__fzf_defaults "--reverse" "${FZF_COMPLETION_OPTS-} $str_arg") \
    FZF_DEFAULT_OPTS_FILE='' \
      __fzf_comprun "${rest[0]}" "${args[@]}" --query "$current" | eval "$post" | command tr '\n' "$output_separator"
  )

  selected=${selected%"$output_separator"} # Strip trailing space not to repeat "-o nospace"

  if [[ -n $selected ]]; then
    COMPREPLY=("${user_prefix}${selected}")
  fi

  bind '"\e[0n": redraw-current-line' 2>/dev/null
  printf '\e[5n'
  return 0
}

_fzf_handle_dynamic_completion() {
  local cmd ret REPLY orig_cmd orig_complete
  cmd="$1"
  shift
  orig_cmd="$1"
  if __fzf_orig_completion_get_orig_func "$cmd"; then
    "$REPLY" "$@"
  elif [[ -n ${_fzf_completion_loader-} ]]; then
    orig_complete=$(complete -p "$orig_cmd" 2>/dev/null)
    $_fzf_completion_loader "$@"
    ret=$?
    # _completion_loader may not have updated completion for the command
    if [[ "$(complete -p "$orig_cmd" 2>/dev/null)" != "$orig_complete" ]]; then
      __fzf_orig_completion < <(complete -p "$orig_cmd" 2>/dev/null)
      __fzf_orig_completion_get_orig_func "$cmd" || ret=1

      # Update orig_complete by _fzf_orig_completion entry
      [[ $orig_complete =~ ' -F '(_fzf_[^ ]+)' ' ]] \
        && __fzf_orig_completion_instantiate "$cmd" "${BASH_REMATCH[1]}" \
        && orig_complete=$REPLY

      if [[ ${__fzf_nospace_commands-} == *" $orig_cmd "* ]]; then
        eval "${orig_complete/ -F / -o nospace -F }"
      else
        eval "$orig_complete"
      fi
    fi
    [[ $ret -eq 0 ]] && return 124
    return $ret
  fi
}

if command -v perl >/dev/null; then
  __fzf_history__() {
    local output script
    # shellcheck disable=2016
    script='BEGIN { getc; $/ = "\n\t"; $HISTCOUNT = $ENV{last_hist} + 1 } s/^[ *]//; s/\n/\n\t/gm; print $HISTCOUNT - $. . "\t$_" if !$seen{$_}++'
    output=$(
      set +o pipefail
      builtin fc -ln -2147483648 \
        | last_hist=$(HISTTIMEFORMAT='' builtin history 1) command perl -n -l0 -e "$script" \
        | FZF_DEFAULT_OPTS=$(__fzf_defaults "" "-n2..,.. --scheme=history --bind=ctrl-r:toggle-sort,alt-r:toggle-raw --wrap-sign '"$'\t'"↳ ' --highlight-line ${FZF_CTRL_R_OPTS-} +m --read0") \
        FZF_DEFAULT_OPTS_FILE='' $(__fzfcmd) --query "$READLINE_LINE"
    ) || return
    READLINE_LINE=$(command perl -pe 's/^\d*\t//' <<<"$output")
    if [[ -z $READLINE_POINT ]]; then
      echo "$READLINE_LINE"
    else
      READLINE_POINT=0x7fffffff
    fi
  }
else # awk - fallback for POSIX systems
  __fzf_history__() {
    local output script
    [[ $(HISTTIMEFORMAT='' builtin history 1) =~ [[:digit:]]+ ]] # how many history entries
    # shellcheck disable=2016
    script='function P(b) { ++n; sub(/^[ *]/, "", b); if (!seen[b]++) { printf "%d\t%s%c", '$((BASH_REMATCH + 1))' - n, b, 0 } }
    NR==1 { b = substr($0, 2); next }
    /^\t/ { P(b); b = substr($0, 2); next }
    { b = b RS $0 }
    END { if (NR) P(b) }'
    output=$(
      set +o pipefail
      builtin fc -ln -2147483648 2>/dev/null \
        |
        # ( $'\t '<lines>$'\n' )* ; <lines> ::= [^\n]* ( $'\n'<lines> )*
        __fzf_exec_awk "$script" \
        |
        # ( <counter>$'\t'<lines>$'\000' )*
        FZF_DEFAULT_OPTS=$(__fzf_defaults "" "-n2..,..  --scheme=history --bind=ctrl-r:toggle-sort,alt-r:toggle-raw --wrap-sign '"$'\t'"↳ ' --highlight-line ${FZF_CTRL_R_OPTS-} +m --read0") \
        FZF_DEFAULT_OPTS_FILE='' $(__fzfcmd) --query "$READLINE_LINE"
    ) || return
    READLINE_LINE=${output#*$'\t'}
    if [[ -z $READLINE_POINT ]]; then
      echo "$READLINE_LINE"
    else
      READLINE_POINT=0x7fffffff
    fi
  }
fi

process_list() {
  if [ "$UID" != "0" ]; then
    command ps -u $UID -awwo user,pid,comm:30,command
  else
    command ps --ppid 2 -p 2 --deselect awwo user,pid,comm:30,command
  fi
}

_fzf_complete_kill() {
  if [ -n "${COMP_WORDS[COMP_CWORD]}" ] && [[ "${COMP_WORDS[COMP_CWORD]}" == -* ]]; then
    return 1
  fi

  _fzf_complete_new --multi --header-lines=1 --reverse --preview 'echo {}' --preview-window down:3:wrap -- "$@" < <(process_list)
}

_fzf_complete_kill_post() {
  awk '{print $2}'
}

_all_users() {
  getent passwd | awk -F: '{print $6,$3,$1}'
}

_fzf_complete_process() {
  if [ -n "${COMP_WORDS[COMP_CWORD]}" ] && [[ "${COMP_WORDS[COMP_CWORD]}" == -* ]]; then
    return 1
  fi

  local prev="${COMP_WORDS[COMP_CWORD - 1]}"

  case $prev in
    --user | -u)
      _fzf_complete_new --no-multi -- "$@" < <(_all_users)
      return 0
      ;;
  esac

  _fzf_complete_new --multi --header-lines=1 --reverse --preview 'echo {}' --preview-window down:3:wrap -- "$@" < <(process_list)
}

_fzf_complete_process_post() {
  awk '{print $3}'
}

FZF_DEFAULT_OPTS="$FZF_DEFAULT_OPTS --ansi"
FZF_CTRL_T_OPTS="--select-1 --exit-0 --preview 'fzf_preview {}'"
FZF_CTRL_T_COMMAND="bfs -color -mindepth 1 -exclude \( -name .git -or -name .keep \) -printf '%P\n' 2>/dev/null"
FZF_ALT_C_COMMAND="bfs -color -mindepth 1 -exclude \( -name .git \) -type d -printf '%P\n' 2>/dev/null"

__fzf_select__() {
  local last_word current_line_until_cursor current_dir=.
  current_line_until_cursor="${READLINE_LINE:0:READLINE_POINT}"
  last_word=$(echo "$current_line_until_cursor" | awk '{print $NF}')

  if [ -n "$last_word" ] && {
    [ -d "$last_word" ] || [[ "$last_word" == ~* ]] || [[ "$last_word" == /* ]]
  }; then
    current_dir="$last_word"
    current_dir="${current_dir/'~'/"$HOME"}"
  fi

  FZF_DEFAULT_COMMAND=${FZF_CTRL_T_COMMAND:-} \
    FZF_DEFAULT_OPTS=$(__fzf_defaults "--reverse --preview-window 'right,<50(down,99%)' --walker=file,dir,follow,hidden --walker-root=$current_dir --scheme=path" "${FZF_CTRL_T_OPTS-} -m") \
    FZF_DEFAULT_OPTS_FILE='' $(__fzfcmd) "$@" \
    | while read -r item; do
      if [ -n "$last_word" ] && [[ "$last_word" == ~* ]]; then
        item="${item/"$HOME"/'~'}"
        item="${item/"$last_word"/}"
      fi
      printf '%q ' "$item" # escape special chars
    done
}

__fzfcmd() {
  [[ -n ${TMUX_PANE-} ]] && {
    [[ ${FZF_TMUX:-0} != 0 ]] || [[ -n ${FZF_TMUX_OPTS-} ]]
  } \
    && echo "fzf-tmux ${FZF_TMUX_OPTS:--d${FZF_TMUX_HEIGHT:-40%}} -- " || echo "fzf"
}

fzf-file-widget() {
  local selected
  selected="$(__fzf_select__ "$@")"
  READLINE_LINE="${READLINE_LINE:0:READLINE_POINT}$selected${READLINE_LINE:READLINE_POINT}"
  READLINE_POINT=$((READLINE_POINT + ${#selected}))
}

__fzf_cd__() {
  local dir
  dir=$(
    # shellcheck disable=2091
    FZF_DEFAULT_COMMAND=${FZF_ALT_C_COMMAND:-} \
      FZF_DEFAULT_OPTS=$(__fzf_defaults "--reverse --walker=dir,follow,hidden --scheme=path" "${FZF_ALT_C_OPTS-} +m") \
      FZF_DEFAULT_OPTS_FILE='' $(__fzfcmd)
  ) && printf 'builtin cd -- %q' "$(builtin unset CDPATH && builtin cd -- "$dir" && builtin pwd)"
}

# v - open files in ~/.viminfo
v() {
  local files
  files=$(grep '^>' ~/.viminfo | cut -c3- \
    | while read -r line; do
      [ -f "${line/\~/$HOME}" ] && echo "${line/\~/$HOME}"
    done | fzf-tmux --select-1 --reverse --inline-info +s \
    --tac --multi --preview 'highlight --force -O ansi -l {} 2> /dev/null | head -200' --query "$*" -1) \
    && vim "${files//\~/$HOME}"
}

fmpc() {
  local song_position
  song_position=$(mpc -f "%position%) %artist% - %title%" playlist \
    | fzf-tmux --query="$1" "$fzf_height" --reverse --inline-info +s --select-1 --exit-0 \
    | sed -ne 's/^\([0-9].*\)).*/\1/p') || return 1
  [ -n "$song_position" ] && mpc -q play "$song_position"
}

# c - browse chrome history
ch() {
  local cols sep google_history open
  cols=$((COLUMNS / 3))
  sep='{::}'

  if [ "$(uname)" = "Darwin" ]; then
    google_history="$HOME/Library/Application Support/Google/Chrome/Default/History"
    open=open
  else
    google_history="$HOME/.config/google-chrome/Profile 1/History"
    open=xdg-open
  fi
  cp -f "$google_history" /tmp/h
  # shellcheck disable=2086
  sqlite3 -separator $sep /tmp/h \
    "select substr(title, 1, $cols), url
      from urls order by last_visit_time desc" \
    | awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' \
    | fzf $fzf_default_options $fzf_height --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open >/dev/null 2>/dev/null
}

# fco - checkout git branch/tag
fco() {
  local tags branches target
  tags=$(
    git tag | awk '{print "\x1b[31;1mtag\x1b[m\t" $1}'
  ) || return
  branches=$(
    git branch --all | grep -v HEAD \
      | sed "s/.* //" | sed "s#remotes/[^/]*/##" \
      | sort -u | awk '{print "\x1b[34;1mbranch\x1b[m\t" $1}'
  ) || return
  # shellcheck disable=2086
  target=$(
    (
      echo "$tags"
      echo "$branches"
    ) \
      | fzf-tmux $fzf_default_options $fzf_height -l30 -- --no-hscroll --ansi +m -d "\t" -n 2
  ) || return
  git checkout "$(echo "$target" | awk '{print $2}')"
}

# fshow - git commit browser
fshow() {
  git log --graph --color=always \
    --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" \
    | fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

# fcs - get git commit sha
# example usage: git rebase -i `fcs`
fcs() {
  local commits commit
  commits=$(git log --color=always --pretty=oneline --abbrev-commit --reverse) \
    && commit=$(echo "$commits" | fzf --tac +s +m -e --ansi --reverse) \
    && echo -n "${commit%% *}"
}

# override __zoxide_z_complete to enable completion without space
__zoxide_z_complete() {
  # Only show completions when the cursor is at the end of the line.
  [[ ${#COMP_WORDS[@]} -eq $((COMP_CWORD + 1)) ]] || return

  if [[ ${#COMP_WORDS[@]} -eq 2 ]]; then

    local prev="${COMP_WORDS[COMP_CWORD]}"

    # shellcheck disable=SC2312
    __zoxide_result="$(_ZO_FZF_OPTS="--query=$prev --preview 'fzf_preview {2..}' --exact --no-sort --bind=ctrl-z:ignore,btab:up,tab:down --cycle --keep-right --info=inline --layout=reverse --tabstop=1 --exit-0" \command zoxide query --exclude "$(__zoxide_pwd)" --interactive)" && {
      # In case the terminal does not respond to \e[5n or another
      # mechanism steals the response, it is still worth completing
      # the directory in the command line.
      # shellcheck disable=2154
      COMPREPLY=("${__zoxide_z_prefix}${__zoxide_result}/")

      # Note: We here call "bind" without prefixing "\builtin" to be
      # compatible with frameworks like ble.sh, which emulates Bash's
      # builtin "bind".
      bind -x '"\e[0n": __zoxide_z_complete_helper'
      \builtin printf '\e[5n' >/dev/tty
    }
  fi
}

_complete_ssh() {
  _complete "$@" < <(give_me_hostname ssh)
}

_complete_net() {
  _complete "$@" < <(give_me_hostname)
}

_fzf_complete_ssh_keys() {
  _fzf_complete_new --no-multi -- "$@" < <(_fzf_privkey)
}

_fzf_complete_ssh() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    -i)
      _fzf_complete_ssh_keys "$@"
      return 0
      ;;
  esac
  _fzf_complete_new --no-multi -- "$@" < <(give_me_hostname ssh)
}

_fzf_complete_ansible() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    -i)
      _fzf_complete_new --multi --output_separator=, -- "$@" < <(give_me_hostname ssh)
      return 0
      ;;
    -l)
      _fzf_complete_new --multi --output_separator=, -- "$@" < <(_fzf_ansible_groups)
      return 0
      ;;
    -u)
      return 0
      ;;
  esac

  _fzf_complete_new --multi -- "$@" < <(_fzf_playbook)
}

_fzf_complete_dsh() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    -g)
      _fzf_complete_new --multi --output_separator=, -- "$@" < <(_fzf_dsh_groups)
      return 0
      ;;
  esac
}

_fzf_complete_pacman() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    -Rcs | -Qo | -Qi | -Ql | -Sii)
      _fzf_complete_new --multi --preview 'yay --color always -Qli {1}' -- "$@" < <(_fzf_archlinux_installed_packages)
      return 0
      ;;
  esac
}

_fzf_complete_archlinux_installed_packages() {
  _fzf_complete_new --multi --preview 'yay --color always -Qli {1}' -- "$@" < <(_fzf_archlinux_installed_packages)
}

_fzf_complete_pssh() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    --hosts | -h)
      _fzf_complete_new --no-multi -- "$@" < <(_fzf_ansible_groups)
      return 0
      ;;
  esac
}

_fzf_complete_pssh_post() {
  # shellcheck disable=2088
  echo "~/.dsh/group/$(cat -)"
}

_fzf_complete_net() {
  _fzf_complete_new --no-multi -- "$@" < <(give_me_hostname)
}

_fzf_complete_ips() {
  _fzf_complete_new --no-multi -- "$@" < <(give_me_hostname ips)
}

_fzf_complete_docker() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  local FZF_DOCKER_PS_FORMAT="table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Ports}}"
  local FZF_DOCKER_PS_START_FORMAT="table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Image}}"

  # Get all Docker commands
  #
  # Cut below "Management Commands:", then exclude "Management Commands:",
  # "Commands:" and the last line of the help. Then keep the first column and
  # delete empty lines
  DOCKER_COMMANDS=$(
    command docker --help 2>&1 \
      | sed -n -e '/Management Commands:/,$p' \
      | grep -Fv -e "Management Commands:" -e "Commands:" -e 'COMMAND --help' \
      | grep .
  )

  case $prev in
    'stop' | 'exec' | 'kill' | 'restart' | '-it')
      _fzf_complete_new --multi --header-lines=1 -- "$@" < <(
        docker ps --format "${FZF_DOCKER_PS_FORMAT}"
      )
      ;;
    'tag' | '-f' | 'run' | 'push')
      _fzf_complete_new --multi --header-lines=1 -- "$@" < <(
        command docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.ID}}\t{{.CreatedSince}}"
      )
      ;;
    'rmi')
      _fzf_complete_new --multi --header-lines=1 -- "$@" < <(
        docker images --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}\t{{.Size}}"
      )
      ;;
    'logs')
      _fzf_complete_new --multi --header-lines=1 --header "Enter CTRL-O to open log in editor | CTRL-/ to change height" --bind 'ctrl-/:change-preview-window(80%,border-bottom|)' --bind "ctrl-o:execute:docker logs {1} | sed 's/\x1b\[[0-9;]*m//g' | cat | ${EDITOR:-vim} -" --preview-window up:follow --preview 'docker logs --follow --tail=100 {1}' -- "$@" < <(
        docker ps -a --format "${FZF_DOCKER_PS_FORMAT}"
      )
      ;;
    'rm')
      _fzf_complete_new --multi --header-lines=1 -- "$@" < <(
        docker ps -a --format "${FZF_DOCKER_PS_FORMAT}"
      )
      ;;
    'start')
      _fzf_complete_new --multi --header-lines=1 -- "$@" < <(
        docker ps -a --format "${FZF_DOCKER_PS_START_FORMAT}"
      )
      ;;
    'docker')
      _fzf_complete_new --reverse -n 1 --height=80% -- "$@" < <(
        echo "$DOCKER_COMMANDS"
      )
      ;;
  esac
}

_fzf_complete_docker_post() {
  # Post-process the fzf output to keep only the command name and not the explanation with it
  awk '{print $1}'
}

_fzf_complete_man() {
  _fzf_complete_new --no-multi --header-lines=1 --prompt='man> ' --preview $'echo {} | tr -d \'()\' | awk \'{printf "%s ", $2} {print $1}\' | xargs -r batman --color always' -- "$@" < <(
    man -k .
  )
}

_fzf_complete_man_post() {
  tr -d '()' | awk '{print $2, $1}'
}

if command -v fzf >/dev/null 2>&1; then
  complete -o default -o bashdefault -o nospace -F _fzf_complete_net "${net_tools[@]}"
  complete -o default -o bashdefault -o nospace -F _fzf_complete_ssh "${ssh_tools[@]}"
  complete -o default -o bashdefault -o nospace -F _fzf_complete_ssh_keys ssh-add
  complete -o default -o bashdefault -o nospace -F _fzf_complete_ips whois
  complete -o default -o bashdefault -o nospace -F _fzf_complete_ansible ansible-playbook ap
  complete -o default -o bashdefault -o nospace -F _fzf_complete_pacman yaourt pacman yay
  complete -o default -o bashdefault -o nospace -F _fzf_complete_archlinux_installed_packages pactree
  complete -o default -o bashdefault -o nospace -F _fzf_complete_dsh dsh
  complete -o default -o bashdefault -o nospace -F _fzf_complete_pssh pssh psshscp
  complete -o default -o bashdefault -o nospace -F _fzf_complete_kill kill
  complete -o default -o bashdefault -o nospace -F _fzf_complete_process "${process_tools[@]}"
  complete -o default -o bashdefault -F _fzf_complete_docker docker
  complete -o default -o bashdefault -F _fzf_complete_man man
else
  complete -o default -o bashdefault -o nospace -F _complete_net "${net_tools[@]}"
  complete -o default -o bashdefault -o nospace -F _complete_ssh "${ssh_tools[@]}"
fi

# Required to refresh the prompt after fzf
bind -m emacs-standard '"\C-\e(": redraw-current-line'

bind -m vi-command '"\C-z": emacs-editing-mode'
bind -m vi-insert '"\C-z": emacs-editing-mode'
bind -m emacs-standard '"\C-z": vi-editing-mode'
# CTRL-R - Paste the selected command from history into the command line
bind -m emacs-standard -x '"\C-r": __fzf_history__'
bind -m vi-command -x '"\C-r": __fzf_history__'
bind -m vi-insert -x '"\C-r": __fzf_history__'
# CTRL-f - Paste the selected file path into the command line
bind -m emacs-standard -x '"\C-f": fzf-file-widget'
bind -m vi-command -x '"\C-f": fzf-file-widget'
bind -m vi-insert -x '"\C-f": fzf-file-widget'
# ALT-S - cd into the selected directory
# shellcheck disable=2016
bind -m emacs-standard '"\es": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\C-\e(\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d\C-y\ey\C-_"'
bind -m vi-command '"\es": "\C-z\es\C-z"'
bind -m vi-insert '"\es": "\C-z\es\C-z"'
