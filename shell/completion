# shellcheck shell=bash
# shellcheck disable=SC2034
give_me_hostname="give_me_hostname"
fzf_default_options="-i --select-1 --exit-0 --tac --tiebreak=length,begin,index --reverse --inline-info"
fzf_height="--height ${FZF_TMUX_HEIGHT:-50%} --min-height 25"

export COMP_WORDBREAKS=${COMP_WORDBREAKS/\:/}
export FZF_COMPLETION_TRIGGER='**'

# Tools to complete
net_tools=(
  ping
  host
  mtr
  mosh
  telnet
  ftp
  lftp
  dig
  drill
  nslookup
  ansible
  nmap
)

ssh_tools=(
  ssh
  s
  n
  rsync
  scp
  sftp
  proo
  curl
  ssh-audit
  update-services
  connect_to_proo
  mysql_get_root_password
)

# Use fd (https://github.com/sharkdp/fd) instead of the default find
# command for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
_fzf_compgen_path() {
  if command -v fd > /dev/null 2>&1; then
    fd --hidden --max-depth 5 --follow --exclude ".git" . "$1"
  else
    echo "$1"
    command find -L "$1" \
      -name .git -prune -o -name .hg -prune -o -name .svn -prune -o \( -type d -o -type f -o -type l \) \
      -a -not -path "$1" -print 2> /dev/null | command sed 's@^\./@@'
  fi
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
  if command -v fd > /dev/null 2>&1; then
    fd --type d --hidden --max-depth 3 --follow --exclude ".git" . "$1"
  else
    command find -L "$1" \
      -name .git -prune -o -name .hg -prune -o -name .svn -prune -o -type d \
      -a -not -path "$1" -print 2> /dev/null | command sed 's@^\./@@'
  fi
}

# To redraw line after fzf closes (printf '\e[5n')
bind '"\e[0n": redraw-current-line'

# fzf default completion
#[[ -f /usr/share/fzf/completion.bash ]] && source /usr/share/fzf/completion.bash

_complete() {
  local cur="${COMP_WORDS[COMP_CWORD]}"

  if [[ ${cur} == *@* ]]; then
    local opts="-P ${cur/@*/}@ -- ${cur/*@/}"
  else
    local opts=" -- ${cur}"
  fi
  # shellcheck disable=SC2086
  COMPREPLY=($(compgen -W "$(< /dev/stdin)" ${opts}))
  return 0
}

_fzf_privkey() {
  find "$HOME/.ssh" -type f -name 'id_*' | grep -v '.pub'
}

_fzf_playbook() {
  find playbooks -maxdepth 1 -type f -name '*.yml'
}

_fzf_ansible_groups() {
  local inventory
  if [ -e "$HOME"/.ansible.cfg ] && grep -q inventory "$HOME"/.ansible.cfg; then
    inventory=$(awk '/inventory/ {print $3}' "$HOME"/.ansible.cfg)
    inventory=${inventory/\~/$HOME}
  elif [ -e ansible.cfg ] && grep -q inventory ansible.cfg; then
    inventory=$(awk '/inventory/ {print $3}' ansible.cfg)
  fi
  ansible-inventory --list | jq -r "keys | .[]"
}

_fzf_dsh_groups() {
  local inventory
  inventory="$HOME/.dsh/group"
  if [ -d "$inventory" ]; then
    ls -1 "$inventory"
  fi
}

_fzf_archlinux_installed_packages() {
  pacman -Qq
}

_fzf_log() {
  local cmd log_file
  cmd="command find /var/log/ -type f -name '*log' 2>/dev/null"
  log_file=$(eval "$cmd" | fzf "$fzf_height" --tac --tiebreak=length,begin,index --reverse --inline-info) && less "$log_file"
}

_fzf_complete() {
  local selected fzf post caller
  local current="${COMP_WORDS[COMP_CWORD]}"
  local user_prefix=''
  local options="${1:-'--multi'}"
  local separator=${2:- }
  local preview="fzf_preview {}"
  caller=$(caller 0 | awk '{print $2}')
  local delete="fzf_delete $caller {}"

  post="${caller}_post"
  type -t "$post" > /dev/null 2>&1 || post='command cat'
  fzf="fzf $fzf_default_options $options $fzf_height --preview-window right:75%:hidden --bind ?:toggle-preview"

  if [[ ${current} == *@* ]]; then
    user_prefix="${current/@*/}@"
    current="${current/*@/}"
  fi
  selected=$(cat | $fzf --preview "$preview" --bind "alt-bspace:execute:$delete" --query "$current" | $post | tr '\n' "$separator")
  selected=${selected%"$separator"} # Strip trailing space not to repeat "-o nospace"
  printf '\e[5n'

  if [ -n "$selected" ]; then
    COMPREPLY=("${user_prefix}${selected}")
    return 0
  fi
}

__fzf_exec_awk() {
  __fzf_awk='awk'
  LC_ALL=C exec "$__fzf_awk" "$@"
}

__fzf_comprun() {
  if [[ "$(type -t _fzf_comprun 2>&1)" == function ]]; then
    _fzf_comprun "$@"
  elif [[ -n ${TMUX_PANE-} ]] && { [[ ${FZF_TMUX:-0} != 0 ]] || [[ -n ${FZF_TMUX_OPTS-} ]]; }; then
    shift
    fzf-tmux ${FZF_TMUX_OPTS:--d${FZF_TMUX_HEIGHT:-40%}} -- "$@"
  else
    shift
    fzf "$@"
  fi
}

__fzf_orig_completion() {
  local l comp f cmd
  while read -r l; do
    if [[ $l =~ ^(.*\ -F)\ *([^ ]*).*\ ([^ ]*)$ ]]; then
      comp="${BASH_REMATCH[1]}"
      f="${BASH_REMATCH[2]}"
      cmd="${BASH_REMATCH[3]}"
      [[ $f == _fzf_* ]] && continue
      printf -v "_fzf_orig_completion_${cmd//[^A-Za-z0-9_]/_}" "%s" "${comp} %s ${cmd} #${f}"
      if [[ $l == *" -o nospace "* ]] && [[ ${__fzf_nospace_commands-} != *" $cmd "* ]]; then
        __fzf_nospace_commands="${__fzf_nospace_commands-} $cmd "
      fi
    fi
  done
}

# @param $1 cmd - Command name for which the original completion is searched
# @var[out] REPLY - Original function name is returned
__fzf_orig_completion_get_orig_func() {
  local cmd orig_var orig
  cmd=$1
  orig_var="_fzf_orig_completion_${cmd//[^A-Za-z0-9_]/_}"
  orig="${!orig_var-}"
  REPLY="${orig##*#}"
  [[ $REPLY ]] && type "$REPLY" &> /dev/null
}

# @param $1 cmd - Command name for which the original completion is searched
# @param $2 func - Fzf's completion function to replace the original function
# @var[out] REPLY - Completion setting is returned as a string to "eval"
__fzf_orig_completion_instantiate() {
  local cmd func orig_var orig
  cmd=$1
  func=$2
  orig_var="_fzf_orig_completion_${cmd//[^A-Za-z0-9_]/_}"
  orig="${!orig_var-}"
  orig="${orig%#*}"
  [[ $orig == *' %s '* ]] || return 1
  printf -v REPLY "$orig" "$func"
}

__fzf_defaults() {
  printf '%s\n' "--height ${FZF_TMUX_HEIGHT:-40%} --min-height 20+ --bind=ctrl-z:ignore $1"
  command cat "${FZF_DEFAULT_OPTS_FILE-}" 2> /dev/null
  printf '%s\n' "${FZF_DEFAULT_OPTS-} $2"
}

_fzf_complete_new() {
  # Split arguments around --
  local args rest str_arg i sep output_separator=" " default_preview=true
  args=("$@")
  sep=
  for i in "${!args[@]}"; do
    if [[ ${args[$i]} = "--output_separator="* ]]; then
      output_separator="${args[i]#*=}"
      unset 'args[i]'
    fi
    if [[ ${args[$i]} = "--preview" ]]; then
      default_preview=false
    fi
    if [[ ${args[$i]} == -- ]]; then
      sep=$i
      break
    fi
  done
  if [[ -n $sep ]]; then
    str_arg=
    rest=("${args[@]:$((sep + 1)):${#args[@]}}")
    args=("${args[@]:0:sep}")
  else
    str_arg=$1
    args=()
    shift
    rest=("$@")
  fi

  local cur selected cmd post caller user_prefix=''
  local preview="fzf_preview {}"
  caller=$(caller 0 | awk '{print $2}')
  local delete="fzf_delete $caller {}"
  post="${caller}_post"
  type -t "$post" > /dev/null 2>&1 || post='command cat'

  if [ "$default_preview" = true ] ; then
    args+=(--preview "$preview" --preview-window right:75%:hidden --bind ?:toggle-preview)
  fi
  args+=(--bind "alt-bspace:execute:$delete")

  cmd="${COMP_WORDS[0]}"
  cur="${COMP_WORDS[COMP_CWORD]}"

  if [[ ${cur} == *@* ]]; then
    user_prefix="${cur/@*/}@"
    cur="${cur/*@/}"
  fi

  selected=$(
    FZF_DEFAULT_OPTS=$(__fzf_defaults "--reverse" "${FZF_COMPLETION_OPTS-} $str_arg") \
    FZF_DEFAULT_OPTS_FILE='' \
      __fzf_comprun "${rest[0]}" "${args[@]}" -q "$cur" | eval "$post" | command tr '\n' "$output_separator"
  )
  selected=${selected%"$output_separator"} # Strip trailing space not to repeat "-o nospace"
  if [[ -n $selected ]]; then
    COMPREPLY=("${user_prefix}${selected}")
  else
    COMPREPLY=("$cur")
  fi
  bind '"\e[0n": redraw-current-line' 2> /dev/null
  printf '\e[5n'
  return 0
}

_fzf_handle_dynamic_completion() {
  local cmd ret REPLY orig_cmd orig_complete
  cmd="$1"
  shift
  orig_cmd="$1"
  if __fzf_orig_completion_get_orig_func "$cmd"; then
    "$REPLY" "$@"
  elif [[ -n ${_fzf_completion_loader-} ]]; then
    orig_complete=$(complete -p "$orig_cmd" 2> /dev/null)
    $_fzf_completion_loader "$@"
    ret=$?
    # _completion_loader may not have updated completion for the command
    if [[ "$(complete -p "$orig_cmd" 2> /dev/null)" != "$orig_complete" ]]; then
      __fzf_orig_completion < <(complete -p "$orig_cmd" 2> /dev/null)
      __fzf_orig_completion_get_orig_func "$cmd" || ret=1

      # Update orig_complete by _fzf_orig_completion entry
      [[ $orig_complete =~ ' -F '(_fzf_[^ ]+)' ' ]] &&
        __fzf_orig_completion_instantiate "$cmd" "${BASH_REMATCH[1]}" &&
        orig_complete=$REPLY

      if [[ ${__fzf_nospace_commands-} == *" $orig_cmd "* ]]; then
        eval "${orig_complete/ -F / -o nospace -F }"
      else
        eval "$orig_complete"
      fi
    fi
    [[ $ret -eq 0 ]] && return 124
    return $ret
  fi
}

__fzf_history__() {
  local line
  shopt -u nocaseglob nocasematch
  line=$(
    # shellcheck disable=SC1007
    HISTTIMEFORMAT= history \
      | FZF_DEFAULT_OPTS="$fzf_height $fzf_default_options --tac -n2..,.. --tiebreak=index --bind=ctrl-r:toggle-sort $FZF_CTRL_R_OPTS +m" fzf \
      | command grep '^ *[0-9]'
  ) \
    && if [[ $- =~ H ]]; then
      sed 's/^ *\([0-9]*\)\** .*/!\1/' <<< "$line"
    else
      sed 's/^ *\([0-9]*\)\** *//' <<< "$line"
    fi
}

_fzf_complete_kill() {
  [ -n "${COMP_WORDS[COMP_CWORD]}" ] && return 1

  local selected fzf
  fzf="fzf"
  selected=$(ps -ef | sed 1d | FZF_DEFAULT_OPTS="$fzf_height \
      --reverse $FZF_DEFAULT_OPTS --preview 'echo {}' --preview-window down:3:wrap \
      $FZF_COMPLETION_OPTS" $fzf --multi | awk '{print $2}' | tr '\n' ' ')
  printf '\e[5n'

  if [ -n "$selected" ]; then
    COMPREPLY=("$selected")
    return 0
  fi
}

__fzf_select__() {
  local cmd="${FZF_CTRL_T_COMMAND:-"command find -L . -mindepth 1 \\( -path '*/\\.*' -o -fstype 'devfs' -o -fstype 'devtmpfs' -o -fstype 'proc' \\) -prune \
    -o -type f -print \
    -o -type d -print \
    -o -type l -print 2> /dev/null | cut -b3-"}"

  eval "$cmd" | FZF_DEFAULT_OPTS="$fzf_height --reverse $FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS --preview='fzf_preview {}'" fzf -m "$@" | while read -r item; do
    printf '%q ' "$item"
  done
  echo
}

_fzf_file_widget() {
  local selected
  selected="$(__fzf_select__ "$@")"
  READLINE_LINE="${READLINE_LINE:0:$READLINE_POINT}$selected${READLINE_LINE:$READLINE_POINT}"
  READLINE_POINT=$((READLINE_POINT + ${#selected}))
}

__fzf_cd__() {
  local cmd dir
  cmd="${FZF_ALT_C_COMMAND:-"command find -L . \\( -path '*/\\.*' -o -fstype 'devfs' -o -fstype 'devtmpfs' -o -fstype 'proc' \\) -prune \
    -o -type d -print 2> /dev/null | sed 1d | cut -b3-"}"
  dir=$(eval "$cmd" | FZF_DEFAULT_OPTS="$fzf_height --reverse $FZF_DEFAULT_OPTS $FZF_ALT_C_OPTS" fzf +m) && printf 'cd %q' "$dir"
}

# v - open files in ~/.viminfo
v() {
  local files
  files=$(grep '^>' ~/.viminfo | cut -c3- \
    | while read -r line; do
      [ -f "${line/\~/$HOME}" ] && echo "${line/\~/$HOME}"
    done | fzf-tmux --select-1 --reverse --inline-info +s \
    --tac --multi --preview 'highlight --force -O ansi -l {} 2> /dev/null | head -200' --query "$*" -1) \
    && vim "${files//\~/$HOME}"
}

fmpc() {
  local song_position
  song_position=$(mpc -f "%position%) %artist% - %title%" playlist \
    | fzf-tmux --query="$1" "$fzf_height" --reverse --inline-info +s --select-1 --exit-0 \
    | sed -ne 's/^\([0-9].*\)).*/\1/p') || return 1
  [ -n "$song_position" ] && mpc -q play "$song_position"
}

# c - browse chrome history
ch() {
  local cols sep google_history open
  cols=$((COLUMNS / 3))
  sep='{::}'

  if [ "$(uname)" = "Darwin" ]; then
    google_history="$HOME/Library/Application Support/Google/Chrome/Default/History"
    open=open
  else
    google_history="$HOME/.config/google-chrome/Profile 1/History"
    open=xdg-open
  fi
  cp -f "$google_history" /tmp/h
  # shellcheck disable=2086
  sqlite3 -separator $sep /tmp/h \
    "select substr(title, 1, $cols), url
     from urls order by last_visit_time desc" \
    | awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' \
    | fzf $fzf_default_options $fzf_height --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open > /dev/null 2> /dev/null
}

# fco - checkout git branch/tag
fco() {
  local tags branches target
  tags=$(
    git tag | awk '{print "\x1b[31;1mtag\x1b[m\t" $1}'
  ) || return
  branches=$(
    git branch --all | grep -v HEAD \
      | sed "s/.* //" | sed "s#remotes/[^/]*/##" \
      | sort -u | awk '{print "\x1b[34;1mbranch\x1b[m\t" $1}'
  ) || return
  # shellcheck disable=2086
  target=$(
    (
      echo "$tags"
      echo "$branches"
    ) \
      | fzf-tmux $fzf_default_options $fzf_height -l30 -- --no-hscroll --ansi +m -d "\t" -n 2
  ) || return
  git checkout "$(echo "$target" | awk '{print $2}')"
}

# fshow - git commit browser
fshow() {
  git log --graph --color=always \
    --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" \
    | fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

# fcs - get git commit sha
# example usage: git rebase -i `fcs`
fcs() {
  local commits commit
  commits=$(git log --color=always --pretty=oneline --abbrev-commit --reverse) \
    && commit=$(echo "$commits" | fzf --tac +s +m -e --ansi --reverse) \
    && echo -n "$(echo "$commit" | sed "s/ .*//")"
}

_complete_ssh() {
  _complete "$@" < <(give_me_hostname ssh)
}

_complete_net() {
  _complete "$@" < <(give_me_hostname)
}

_fzf_complete_ssh() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    -i)
      _fzf_complete_new --no-multi -- "$@" < <(_fzf_privkey)
      return 0
      ;;
  esac
  _fzf_complete_new --no-multi -- "$@" < <(give_me_hostname ssh)
}

_fzf_complete_ansible() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    -i)
      _fzf_complete_new --multi --output_separator=, -- "$@" < <(give_me_hostname ssh)
      return 0
      ;;
    -l)
      _fzf_complete_new --multi --output_separator=, -- "$@" < <(_fzf_ansible_groups)
      return 0
      ;;
    -u)
      return 0
      ;;
  esac

  _fzf_complete_new --multi -- "$@" < <(_fzf_playbook)
}

_fzf_complete_dsh() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    -g)
      _fzf_complete_new --multi --output_separator=, -- "$@" < <(_fzf_dsh_groups)
      return 0
      ;;
  esac
}

_fzf_complete_pacman() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    -Rcs | -Qo | -Qi | -Ql | -Sii)
      _fzf_complete_new --multi -- "$@" < <(_fzf_archlinux_installed_packages)
      return 0
      ;;
  esac
}

_fzf_complete_archlinux_installed_packages() {
  _fzf_complete_new --multi -- "$@" < <(_fzf_archlinux_installed_packages)
}

_fzf_complete_pssh() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  case $prev in
    --hosts | -h)
      _fzf_complete_new --no-multi -- "$@" < <(_fzf_ansible_groups)
      return 0
      ;;
  esac
}

_fzf_complete_pssh_post() {
  # shellcheck disable=2088
  echo "~/.dsh/group/$(cat -)"
}

_fzf_complete_net() {
  _fzf_complete_new --no-multi -- "$@" < <(give_me_hostname)
}

_fzf_complete_ips() {
  _fzf_complete_new --no-multi -- "$@" < <(give_me_hostname ips)
}

_fzf_complete_docker() {
  local prev="${COMP_WORDS[COMP_CWORD - 1]}"
  local FZF_DOCKER_PS_FORMAT="table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Ports}}"
  local FZF_DOCKER_PS_START_FORMAT="table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Image}}"

  # Get all Docker commands
  #
  # Cut below "Management Commands:", then exclude "Management Commands:",
  # "Commands:" and the last line of the help. Then keep the first column and
  # delete empty lines
  DOCKER_COMMANDS=$(
    command docker --help 2>&1 \
      | sed -n -e '/Management Commands:/,$p' \
      | grep -Fv -e "Management Commands:" -e "Commands:" -e 'COMMAND --help' \
      | grep .
  )

  case $prev in
    'stop' | 'exec' | 'kill' | 'restart')
      _fzf_complete_new --multi --header-lines=1  -- "$@" < <(
        docker ps --format "${FZF_DOCKER_PS_FORMAT}"
      )
      ;;
    'tag' | '-f' | 'run' | 'push')
      _fzf_complete_new --multi --header-lines=1 -- "$@" < <(
        command docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.ID}}\t{{.CreatedSince}}"
      )
      ;;
    'rmi')
      _fzf_complete_new --multi --header-lines=1 -- "$@" < <(
        docker images --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}\t{{.Size}}"
      )
      ;;
    'logs')
      _fzf_complete_new --multi --header-lines=1 --header "Enter CTRL-O to open log in editor | CTRL-/ to change height" --bind 'ctrl-/:change-preview-window(80%,border-bottom|)' --bind "ctrl-o:execute:docker logs {1} | sed 's/\x1b\[[0-9;]*m//g' | cat | ${EDITOR:-vim} -" --preview-window up:follow --preview 'docker logs --follow --tail=100 {1}'  -- "$@" < <(
        docker ps -a --format "${FZF_DOCKER_PS_FORMAT}"
      )
      ;;
    'rm')
      _fzf_complete_new --multi --header-lines=1  -- "$@" < <(
        docker ps -a --format "${FZF_DOCKER_PS_FORMAT}"
      )
      ;;
    'start')
      _fzf_complete_new --multi --header-lines=1  -- "$@" < <(
        docker ps -a --format "${FZF_DOCKER_PS_START_FORMAT}"
      )
      ;;
    'docker')
      _fzf_complete_new --reverse -n 1 --height=80% -- "$@" < <(
        echo "$DOCKER_COMMANDS"
      )
      ;;
  esac
}

_fzf_complete_docker_post() {
  # Post-process the fzf output to keep only the command name and not the explanation with it
  awk '{print $1}'
}

if hash fzf 2> /dev/null; then
  complete -o default -o bashdefault -o nospace -F _fzf_complete_net "${net_tools[@]}"
  complete -o default -o bashdefault -o nospace -F _fzf_complete_ssh "${ssh_tools[@]}"
  complete -o default -o bashdefault -o nospace -F _fzf_complete_ips whois
  complete -o default -o bashdefault -o nospace -F _fzf_complete_ansible ansible-playbook ap
  complete -o default -o bashdefault -o nospace -F _fzf_complete_pacman yaourt pacman yay
  complete -o default -o bashdefault -o nospace -F _fzf_complete_archlinux_installed_packages pactree
  complete -o default -o bashdefault -o nospace -F _fzf_complete_dsh dsh
  complete -o default -o bashdefault -o nospace -F _fzf_complete_pssh pssh psshscp
  complete -o default -o bashdefault -F _fzf_complete_docker docker
else
  complete -o default -o bashdefault -o nospace -F _complete_net "${net_tools[@]}"
  complete -o default -o bashdefault -o nospace -F _complete_ssh "${ssh_tools[@]}"
fi

# Kill completion
complete -F _fzf_complete_kill -o nospace -o default -o bashdefault kill

# Required to refresh the prompt after fzf
bind '"\er": redraw-current-line'
bind '"\e^": history-expand-line'
# CTRL-R - Paste the selected command from history into the command line
# shellcheck disable=SC2016
bind '"\C-r": " \C-e\C-u`__fzf_history__`\e\C-e\e^\er"'
# CTRL-f - Paste the selected file path into the command line
bind -x '"\C-f": "_fzf_file_widget"'
# ALT-S - cd into the selected directory
# shellcheck disable=SC2016
bind '"\es": " \C-e\C-u`__fzf_cd__`\e\C-e\er\C-m"'
