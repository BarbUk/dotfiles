#!/usr/bin/env bash
# video demo at: http://www.youtube.com/watch?v=90xoathBYfk

# augmented by "opennomad": https://gist.github.com/opennomad/15c4d624dce99066a82d
# originally written by "mhwombat": https://bbs.archlinux.org/viewtopic.php?id=71938&p=2
# Based on "snippy" by "sessy"
# (https://bbs.archlinux.org/viewtopic.php?id=71938)
#
# You will also need "dmenu", "zenity", "xsel" and "xdotool". Get them from your linux
# distro in the usual way.
#
# To use:
# 1. Create the directory ~/.snippy
#
# 2. Create a file in that directory for each snippet that you want.
#    The filename will be used as a menu item, so you might want to
#    omit the file extension when you name the file.
#
#    TIP: If you have a lot of snippets, you can organise them into
#    subdirectories under ~/.snippy.
#
#    TIP: The contents of the file will be pasted asis, so if you
#    don't want a newline at the end when the text is pasted, don't
#    put one in the file.
#
# 3. Bind a convenient key combination to this script.
#
#    TIP: If you're using XMonad, add something like this to xmonad.hs
#      ((mod4Mask, xK_s), spawn "/path/to/snippy")
#
# 4. Set variables in ~/.snippy.conf. for example
#    MENU_ENGINE="dmenu"
#    DMENU_ARGS=' -p snippy -fn arial -sf green'
#    ZENITY_ARGS='--list --hide-header --column=Snippet --text=snippy'
#    GUIPASTE="xdotool key ctrl+v"
#    CLIPASTE="xdotool key ctrl+shift+v"


CONFIG=${HOME}/.snippy.conf
APPS="xdotool xsel dmenu zenity"
DIR=${HOME}/.snippy
MENU_ENGINE="dmenu"
. ~/.dmenurc
DMENU_ARGS="$DMENU_CONF -l 10 -p Snippets:"
ZENITY_ARGS='--list --hide-header --column=Snippet --text=snippy'
# if nothing happens, try "xdotool click 2", "xdotool key ctrl+v" or "xdotool key ctrl+shift+v"
GUIPASTE="xdotool key ctrl+v"
CLIPASTE="xdotool key ctrl+shift+v"

TMPFILE="/tmp/.snippy.tmp"; :>$TMPFILE

# source the config file if it exists
[[ -f ${CONFIG} ]] && source ${CONFIG}

# set the menu options depending on the engine
case ${MENU_ENGINE} in
  'dmenu')
    MENU_ARGS=${DMENU_ARGS}
    ;;
  'zenity')
    MENU_ARGS=${ZENITY_ARGS}
    ;;
  *)
    echo "incorrecty MENU_ENGINE: ${MENU_ENGINE} for snippy"
  exit 1
esac

# smarty like template engine which executes inline bash in (bashdown) strings (replaces variables with values e.g.)
# @link http://github.com/coderofsalvation/bashdown
# @dependancies: sed cat
# @example: echo 'hi $NAME it is $(date)' | bashdown
# fetches a document and interprets bashsyntax in string (bashdown) templates
# @param string - string with bash(down) syntax (usually surrounded by ' quotes instead of ")
bashdown(){
    while read line; do
        line="$(eval "printf -- \"$( printf "%s" "$line" | sed 's/"/\\"/g')\"")";
        echo -e "$line"
    done < <(cat "${DIR}/${FILE}")
}

init(){
    for APP in $APPS; do
        command -v "$APP" &>/dev/null || {
            read -p "install the following required utils? : $APPS (y/n)" reply
            [[ "$reply" == "y" ]] && sudo apt-get install "${APPS}";
        }
    done
    [[ ! -d "$DIR" ]] && {
        echo -e "created $DIR\n";
        mkdir "$DIR";
        printf "hi it is \$(date)" > "$DIR/test";
    }
    return 0
}

run(){
    cd "${DIR}"
    # Use the filenames in the snippy directory as menu entries.
    # Get the menu selection from the user.
    FILE=$(find -L .  -type f | grep -v '^\.$' | sed 's!\.\/!!' | ${MENU_ENGINE} ${MENU_ARGS})
    # just return if nothing was selected
    [[ -z "${FILE}" ]] && return 1

    if [ -f "${DIR}/${FILE}" ]; then
        # Put the contents of the selected file into the paste buffer.
        content="$(bashdown < "${DIR}/${FILE}")"
        if [[ "${#content}" == 0 ]]; then
            printf "%s" "${FILE}" > $TMPFILE
        else
            printf "%s" "$content" > $TMPFILE
        fi
    else
        ${FILE} &> $TMPFILE # execute as bashcommand
    fi
    local old=$(xsel -b)
    xsel -b --input < $TMPFILE
    # Paste into the current application.
    if is_window; then
        ${GUIPASTE}
    else
        ${CLIPASTE}
    fi
    echo -ne "$old" | xsel -b --input
}

is_window(){
    name="$(xdotool getwindowname "$(xdotool getwindowfocus)" | tr '[:upper:]' '[:lower:]')"
    [[ "$name" =~ term|tilda|@${HOSTNAME} ]] && return 1
    return 0
}

run
